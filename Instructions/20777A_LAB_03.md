# Module 3: Implementing Server-Side Operations

## Lab: Writing User-Defined Functions, Stored Procedures and Triggers

### Lab Scenario

You have been asked to design an online retail system for a global organization that has thousands of product lines and handles requests from tens of thousands of customers simultaneously. You will be implementing the processing for creating and managing orders. The application should provide the following functionality:

  - Customers can browse the Adventure-Works web site and place items in a virtual shopping cart.

  - Customers can add or remove items from the shopping cart, and change the number of each item ordered.

  - When the customer is ready, the customer can place the order. The application should establish—for each item in the shopping cart—whether there is sufficient stock available and if necessary create a backorder for an item.

  - In the case of insufficient availability, the order will be split. The items available will be ordered whilst the remainder will be placed on backorder.

  - A customer can browse their orders and backorders, and if the items have not been shipped or delivered, the customer can cancel any of their orders or backorders.

  - Whenever an order or backorder is cancelled, an audit document is specifying the order or backorder that was cancelled, and when.

  - Customers must not be able to view or amend the shopping carts, orders, or backorders for other customers. Some form of customer authentication and login will be required.

### Objectives

At the end of this lab, you should be able to:

1.  Design and implement a partition scheme suitable for use with server-side programming.

2.  Implement an application compatible with your design.

3.  Use stored procedures in your applications.

4.  Use triggers in your applications..

### Lab Setup

Estimated time: **120 minutes**  
Virtual machine: **20777A-LON-DEV**  
User name: **LON-DEV\\Administrator**  
Password: **Pa55w.rd**

## Exercise 1: Redesigning the Document Structure and Partitioning Strategy

### Exercise 1 Scenario

In the prototype version of the Adventure-Works app (that you created in the lab for the previous module), different collections were used to hold different types of data; you stored products in one collection and product category data in another. Once you start adding further types of documents, this approach might not be feasible (or desirable) in a solution, especially if that solution requires stored procedures and triggers to implement server-side processing.

The main tasks for this exercise are as follows:

1.  Prepare the environment.

2.  Analyze the technical requirements for partitioning.

3.  Implement the document types.

4.  Create a document database using the Cosmos DB SQL API.

5.  Upload data to Cosmos DB.

### Task 1: Prepare the Environment

Using File Explorer:

  - In **E:\\Labfiles\\Lab03\\Starter**, run **Setup.cmd** as Administrator.

Using the Azure portal:

1.  Create a new Storage account. Add the account to the **20777\_Mod03** resource group; create this resource group if it does not exist.

2.  Create a new blob container. Grant anonymous read access to blobs in the container.

3.  Make a note of the connection string for the storage account.

Using the Azure portal:

1.  Create a new Cosmos DB account using the SQL API. Add the account to the **20777\_Mod03** resource group.

2.  Create a new database named **Adventure-Works**.

3.  Make a note of the **URI** and **Primary Key** of the Cosmos DB account.

### Task 2: Analyze the Technical Requirements for Document Partitioning

Consider the following points:

  - Using multiple collections can be more expensive than using a single collection that is partitioned appropriately (because you incur a financial charge for each collection).

  - The details of each customer must be stored in the database, to enable them to be identified and authenticated.

  - The app should persist customers' shopping carts between sessions. This will require saving them to the database. However, shopping carts should not be retained indefinitely, and after 7 days of inactivity a shopping cart should be removed.

  - For reasons of query efficiency, customers, their shopping carts, and their orders should be in the same collection, and ideally in the same partition within that collection. If this collection is partitioned by `customerid`, then performing a query that specifies the `customerid` will automatically retrieve the details of the customer and all of their orders as a single request.

  - The Adventure-Works app needs to check stock availability of an item when the customer places an order, and if necessary create one or more backorders; this needs to be an atomic operation, to prevent the same items being allocated to multiple customers who happen to be placing orders concurrently. This suggests that this functionality should be implemented as a stored procedure or trigger.

  - Similarly, cancelling an order or cancelling a backorder, and creating the corresponding audit document should also be atomic operations.

  - Stored procedures and triggers are scoped to a partition. You specify the partition in which to run a stored procedure when it is invoked. Triggers are automatically scoped to the partition containing the document being inserted, updated, or deleted. In both cases, stored procedures and triggers cannot query, create, modify, or delete data in any other partition.

  - Inventory data (the number of items in stock) is stored with each product, and product documents are partitioned by subcategory. If the backorders are stored in the same partition as the order, a stored procedure or trigger will not be able to query product availability and at the same time create new backorders (products and backorders will be in different partitions). This suggests that the backorders for a product must be held in the same partition as the products to which they pertain.

  - For the same reason, the audit record of a backorder must be stored in the same partition as the backorder, and the audit record of an order must be stored in the same partition as the order.

**Question**: Assuming that you decide to store the data in a single collection, how should you partition the data? What should you use as the partition key?

**Answer**: Define a field named `partitionkey` for each document. For customers, shopping carts, orders, and order audit documents, this field would represent the customer ID. For products, product category data, backorders, and backorder audit documents, this field would represent the product subcategory—for the reasons covered the lab in the previous module.

**Question**: How should you distinguish the different types of documents in the collection?

**Answer**:Add a field named `doctype` to each document that contains the name of the type of document (`Customer`, `Product`, etc).

**Question**: What is the logical difference between a shopping cart and an order?

**Answer**: Shopping carts and orders are almost the same thing. They both contain a list of order items representing the products being picked or ordered. The primary difference is lifetime. Shopping carts are transitory with a limited duration whereas orders are permanent (they can be cancelled, but the order document should be retained by the system). You can consider the data in a shopping cart to be provisional, and features such the cost of the items are only confirmed when the order is confirmed and any discounts etc are applied.

### Task 3: Implement the Different Types of Documents

1.  Using Visual Studio open the the **Adventure-Works** solution in **E:\\Labfiles\\Lab03\\Starter\\Exercise01\\Adventure-Works**.

2.  Edit the **App.config** file. Set the `EndpointUrl` and `PrimaryKey` settings to the values you recorded for the Cosmos DB account that you created at the beginning of the lab.

3.  In the **Models** folder, edit the **DocumentType.cs** file. This file defines the **DocumentType** class, which will act as an abstract base class for all the different types of documents used by the application. You will implement the functionality that is common to all documents in this class; specifically, the `ttl` and `doctype` fields.
    
    1.  After the comment **TODO: doctype distinguishes the different types of documents in the same collection**, add the following code that implements the `doctype` property:
    
        ```csharp 
        [JsonProperty("doctype")]
        public string DocType { get; set; }
        ```
    
        2.  In the `DocumentType` constructor, after the comment **TODO: Initialize the doctype property**, add the following statement. This code stores the type name of the class in the `DocType` field. At runtime, the class name will be the name of the derived class (*Customer*, *ShoppingCartOrder*, etc) that inherits from the `DocumentType` class.
    
        ```csharp 
        this.DocType = this.GetType().Name;
        ```
    
        3.  After the comment **TODO: ttl of document. By default, ttl is disabled, but can be changed by setting it to a positive integer value (number of seconds)**, add the following field definition. If a document contains a field named `ttl`, Cosmos DB will use this field as the *time to live* for the document:
    
        ```csharp 
        [JsonProperty("ttl")]
        public int TimeToLive { get; set; } = -1;
        ```

4.  Open the **Customer.cs** file in the **Models** folder. This file contains two classes; `CustomerName` and `Customer`. You will populate these classes with fields that define the details of a customer. Note that `Customer` inherits from `DocumentType`, so it will automatically have a `doctype` field and a `ttl` field.
    
    1.  Add the following fields to the `Customer` class. The `name` field contains a subdocument defined using the `CustomerName` class (which is why `CustomerName` is not a descendent of `DocumentType`). Also note that the `partitionkey` field represents the customer ID in the application. The `discountrate` field indicates how much discount the customer will be given on any orders placed:
    
        ```csharp 
        [JsonProperty("partitionkey")]
        public string CustomerID { get; set; }
        
        [JsonProperty("name")]
        public CustomerName CustomerName { get; set; }
        
        [JsonProperty("discountrate")]
        public int DiscountRate { get; set; }
        ```
    
        2.  Add the following fields to the `CustomerName` class:
    
        ```csharp 
        [JsonProperty("title")]
        public string Title { get; set; }
        
        [JsonProperty("firstname")]
        public string FirstName { get; set; }
        
        [JsonProperty("middlename")]
        public string MiddleName { get; set; }
        
        [JsonProperty("lastname")]
        public string LastName { get; set; }
        ```

5.  Open the **ShoppingCartOrder.cs** file in the **Models** folder. This file contains two classes; `OrderItem` and `ShoppingCartOrder`. The same class is used to represent shopping carts and orders. A shopping cart or order will contain one or more order items. Note that `ShoppingCartOrder` inherits from `DocumentType` so it will automatically have a `doctype` field and a `ttl` field.
    
    1.  Add the following fields to the `OrderItem` class. When a customer adds an item to the shopping cart, one of these objects will be created. The `NumberOnBackorder`, `BackorderReference`, `UnitCost`, and `LineItemTotalCost` fields will only be populated when the shopping cart is converted into an order (prices could change while an item is in the shopping cart; remember that the cart can be retained for up to 7 days).
    
        ```csharp 
        [JsonProperty("productnumber")]
        public string ProductNumber { get; set; }
        
        [JsonProperty("productname")]
        public string ProductName { get; set; }
        
        [JsonProperty("productid")]
        public string ProductID { get; set; }
        
        [JsonProperty("subcategory")]
        public string Subcategory { get; set; }
        
        [JsonProperty("numberincartorordered")]
        public int NumberInCartOrOrdered { get; set; }
        
        [JsonProperty("numberonbackorder")]
        public int NumberOnBackorder { get; set; }
        
        [JsonProperty("backorderreference")]
        public string BackorderReference { get; set; }
        
        [JsonProperty("unitcost")]
        public decimal UnitCost { get; set; }
        
        [JsonProperty("lineitemtotalcost")]
        public decimal LineItemTotalCost { get; set; }
        ```
    
        2.  Add the following fields to the `ShoppingCartOrder` class. The field `IsShoppingCartOrOrder` indicates whether this is a shopping cart or order. As with order items, many of these fields are only filled in once the shopping cart becomes an order. Notice that the `partitionkey` field again represents the customer ID. This ensures that the shopping cart and all orders for a customer are stored in the same partition as the customer.
    
        ```csharp
        [JsonProperty("id")]
        public string ShoppingCartOrderID { get; set; }
        
        [JsonProperty("partitionkey")]
        public string CustomerID { get; set; }
        
        [JsonProperty("isshoppingcartororder")]
        public string IsShoppingCartOrOrder { get; set; }
        
        [JsonProperty("orderitems")]
        public List<OrderItem> OrderItems { get; set; }
        
        [JsonProperty("numberofitems")]
        public int NumberOfItems { get; set; }
        
        [JsonProperty("itemscost")]
        public decimal ItemsCost { get; set; }
        
        [JsonProperty("customerdiscountrate")]
        public int CustomerDiscountRate { get; set; } // Indicates % discount
        
        [JsonProperty("totalcost")]
        public decimal TotalCost { get; set; }
        
        [JsonProperty("dateplaced")]
        public long DatePlaced { get; set; } // Stored as ticks
        
        [JsonProperty("orderstatus")]
        public string OrderStatus { get; set; } // "In progress", "Delivered", "Cancelled"
        
        [JsonProperty("lastupdated")]
        public long LastUpdated { get; set; } // Also stored as ticks
        ```

### Task 4: Create a Document Database Using the Cosmos DB SQL API

1.  Add a new collection named **Data** to the **Adventure-Works** database. Use unlimited storage, and **1000** RU/s throughput. Use `/``partitionkey` as the partitioning key.

2.  Build and run the application. Verify that runs without reporting any errors.

### Task 5: Import the Product and Customer Data

The application used in this task imports product data from a local SQL Server database file to your Cosmos DB database, and uploads product images and other binary data to Blob storage. It is similar to that used in previous labs, but is updated to reflect the changes in document structure made in this exercise. As in the lab in the previous module, the source data is provided in a SQL Server database file; the application uses the **(localdb)\\.** SQL Server instance installed with Visual Studio to open the database file.

1.  Using Visual Studio open the the **MigrateProductData** solution in **E:\\Labfiles\\Lab03\\Starter\\Exercise01\\MigrateProductData**.

2.  Edit the **App.config** file. Set the `EndpointUrl` and `PrimaryKey` settings to the values you recorded for the Cosmos DB account that you created at the beginning of the lab. Set the `BlobStorageConnectionString` and `BlobContainer` settings to the values for your storage account that you created at the beginning of the lab.

3.  Build and run the application. Verify that it retrieves the data from SQL Server and uploads the documents to Cosmos DB without reporting any errors. Close the Visual Studio instance with the **MigrateProductData** solution open when the upload process is complete.

4.  Using the Azure portal, go to Data Explorer for the **Data** collection and examine some of the documents.

5.  Use the **Upload** tool in Data Explorer to upload the contents of **E:\\Labfiles\\Lab03\\Data\\categories.json** to the **Data** collection. 38 documents should be uploaded.

6.  Use the **Upload** tool in Data Explorer to upload the contents of **E:\\Labfiles\\Lab03\\Data\\customers.json** to the **Data** collection. 100 documents should be uploaded.

> **Result**: At the end of this exercise, you should have revised the partitioning design for the sales application, implemented the new document types, and uploaded data to Cosmos DB.

## Exercise 2: Implementing the Shopping Cart Functionality

> **Note:** In this exercise, you will extend the functionality of the Adventure-Works web application. You can either continue using the solution from Exercise 1, or open the **Adventure-Works** solution in the E:\\Labs\\Lab03\\Starter\\Exercise02\\Adventure-Works folder. These instructions assume that you use the solution in the E:\\Labs\\Lab03\\Starter\\Exercise02\\Adventure-Works folder.

### Exercise 2 Scenario

The main tasks for this exercise are as follows:

1.  Configure the Adventure-Works application repository classes to allow documents to be saved to Cosmos DB.

2.  Add a simple customer login and logout process.

3.  Implement and test the shopping cart.

### Task 1: Configure the Repository Classes

1.  Using Visual Studio open the the **Adventure-Works.sln** solution in **E:\\Labfiles\\Lab03\\Starter\\Exercise02\\Adventure-Works**.

2.  Edit the **App.config** file. Set the `EndpointUrl` and `PrimaryKey` settings to the values you recorded for the Cosmos DB account that you created at the beginning of the lab. Confirm that the values of the `Database` and `Collection` settings match your Cosmos DB database and collection.

    > **Note**: Remember that all documents now reside in a single collection.

3.  Edit the **Global.asax** file.
    
    1.  After the comment **TODO: Add Customer repository**, add the following statement. This code creates an instance of the `Repository` class for querying and maintaining `Customer` documents in the Cosmos DB database:
    
        ```csharp 
        Repository<Customer>.Initialize(ConfigurationManager.AppSettings["Collection"]);
        ```
    
        1.  After the comment **TODO: Add ShoppingCartOrder repository**, add another statement that creates an instance of the `Repository` class for querying and maintaining `ShoppingCartOrder` documents in the Cosmos DB database:
    
        ```csharp
        Repository<ShoppingCartOrder>.Initialize(ConfigurationManager.AppSettings["Collection"]);
        ```

### Task 2: Complete the Customer Controller to Enable Customers to Login and Logout

1.  In Solution Explorer, expand the **Controllers** folder, and edit the **CustomerController.cs** file. This file is a controller for managing customers in the app. It contains two methods; one for authenticating customers and logging them in, and another for logging them out.

    **Note** These methods are intended to provide simulated security for this app only, and do not reflect best practice for implementing authentication.

2.  In the `LoginAsync` method, after the comment **TODO: Use the repository to retrieve the details of the specified customer**, add the following statement:

    ```csharp
    var customer = (await Repository<Customer>.GetItemsAsync(c => c.CustomerID == customerID)).FirstOrDefault();
    ```

3.  After the comment **TODO: Validation and authentication using the password etc should go here. Only validation is implemented in this example, the user can enter anything in the password field\!** add the following code. If no matching customer is found in the database, the `Login` view (found in the **Shared** views folder in the app) will display the message `Invalid username or password`:

    ```csharp 
    if (customer == null) // No such customer
    {
        TempData["invalidUserOrPassword"] = "Invalid username or password";
        return View();
    }
    ```

4.  After the comment **TODO: If authentication is successful (it always is in this example), cache the customer details in the session**, add the following statement. The customer details are held in the Session cache so that they can be accessed from other actions in the various controllers in the app:

    ``` 
    Session["customer"] = customer;
    ```

5.  After the comment **TODO: Retrieve the current shopping cart for the customer (if there is one)**, add the following statements. This code fetches the shopping cart for the customer and then caches it in the session. Notice that the query checks the `IsShoppingCartOrOrder` field of the document. A shopping cart has the value **ShoppingCart** in this field as opposed to **Order**. The `Constants` class contains the global constants and strings used throughout the web app.

    ```csharp 
    var shoppingCart = (await Repository<ShoppingCartOrder>.GetItemsAsync(c => c.CustomerID == customerID && c.IsShoppingCartOrOrder == Constants.SHOPPINGCART)).FirstOrDefault();
    Session["shoppingCart"] = shoppingCart;
    ```

6.  Review the `Logout` method. All this method does is to remove the details of the customer and other cached items from the session. The `Loggedout` view (another shared view) simply displays a message informing the customer that they have been logged out.

### Task 3: Implement Functionality to Add Items to the Shopping Cart

1.  In Solution Explorer, open the **ShoppingCartController.cs** file in the **Controllers** folder. This file the code for the actions that will run when the customer adds items to the shopping cart, or edits the shopping cart.
    
    1.  Find the `ViewCart` method near the start of the `ShoppingCartController` class. This action runs when the customer wishes to view the contents of their shopping cart.
    
    2.  After the comment **TODO: Check whether the user has logged in**, add the following code. This block examines the Session cache for the `customer` object. If it isn't present, the customer is not currently logged in, so the code switches to the shared `Login` view that prompts the customer for their name and password before invoking the `Login` action, that runs the `LoginAsync` method that you completed in the previous task. One the customer has logged in, the Login action uses the information in the cached `ReturnData` object to return to this `ViewCart` action, when the user should now be logged in:
    
        ```csharp 
        if (Session["customer"] == null)
        {
            // If not, then get them to log in
            Session["ReturnData"] = new { ReturnURL = "ViewCart", Controller = "ShoppingCart" };
            return View("Login");
        }
        ```
    
        3.  After the comment **TODO: Retrieve the shopping cart for the customer**, add the following statement. Remember that when the customer logs in, their shopping cart is cached in the Session. This code simply retrieves the shopping cart from the Session cache:
    
        ```csharp
        var shoppingCart = GetShoppingCartForCustomer(Session["customer"] as Customer);
        ```
    
        4.  After the comment **TODO: Display the shopping cart**, change the `return` statement to pass the shopping cart to the `ViewCart` view for display, as follows:
    
        ```csharp
        return View(shoppingCart);
        ```

2.  In Solution Explorer, in the **Views** folder, expand **ShoppingCart** and review the contents of the **ViewCart.cshtml** file. This is the Razor file that generates the display for the shopping cart. The markup in this file iterates through the `OrderItems` collection in the shopping cart, and displays each line item in turn. Additionally, it displays an edit button for each item that invokes the `EditShoppingCartItem` action that enables the customer to modify the line item, and a delete button that calls the `DeleteShoppingCartItem` action to remove the item from the shopping cart. After all the line items are displayed, a **place order** button appears. If the user clicks this button, the `PlaceOrder` action will run to convert the shopping cart into an order.

3.  Open the **GetProductDetails.cshtml** file in the **View/Products** folder in Solution Explorer. Recall from the previous lab that this view is displayed when the customer displays the details of a product when browsing the catalog. In the previous version of the app, the customer could select an item and click **Buy**. This functionality has been replaced with an **Add to Shopping Cart** button which invokes the `AddItemToShoppingCart` action in the `ShoppingCart` controller:

4.  Return to the **ShoppingCartController.cs** file, and locate the `AddItemToShoppingCartAsync` method. This method runs when the `AddItemToShoppingCart` action is invoked. The parameter is the number required of the specified product. The code in this method ascertains whether the customer is currently logged in, and if not displays the `Login` view. The code then retrieves the shopping cart for the customer, and fetches the details of the selected product (the product id is previously cached in the session). The method then either adds the product to the shopping cart as a new order item, or if the product is already in the shopping cart the code increments the number required by the appropriate amount.
    
      - Find the comment **TODO: Save the shopping cart using the repository, and then cache it in the session. Set the TTL to 7 days. Note that TTL must be enabled at the collection level for this to work**. After this comment, add the following code:
    
        ```csharp
        if (await Repository<ShoppingCartOrder>.UpsertItemAsync(shoppingCart, ttl: 60 * 60 * 24 * 7))
        {
            Session["shoppingCart"] = shoppingCart;
        
            // Inform the user that the item has been added to the cart
            TempData["itemMessage"] = "Item added to shopping cart";
        }
        else
        {
            // If the upsert failed, then inform the user that the item has not been added to the shopping cart
            TempData["itemMessage"] = "Item not added to shopping cart";
        }
        ```

5.  In the Azure Portal, in Document Explorer, select the **Data** collection and then click **Scale & Settings**. In the **Settings** section of the blade, change **Time to Live** to **On (no default)**, and then click **Save**. This setting causes Cosmos DB to automatically expire documents in the collection once they have exceeded the number of seconds specified in the `ttl` field.

6.  Return to Visual Studio. Build and run the application.

7.  In the application, browse the catalog and select a product. On the **Product Details** page click **Add to Shopping Cart**. You should be prompted to log in. You can specify any customer id between 1 and 100 (the password is ignored). The message **Item added to shopping cart** should appear, and the contents of the shopping cart should be displayed by the **ViewCart** view.

8.  In the drop-down menu, click the **Catalog** link, browse again, and add another item to the cart. When the **ViewCart** page appears again, it should now contain two items. You can use the **Update** button to change the quantity, and the **Delete** button to remove an item. Note that if you click **Place Order**, the application will stop with an error because you haven't yet implemented this feature.

9.  Switch back to Document Explorer in the Azure portal. Click **New SQL Query**, and run the following query:

    ```SQL 
    SELECT * FROM c WHERE c.doctype = "ShoppingCartOrder"
    ```

10. Verify that a document similar to that shown below appears. Notice that the `doctype` field is set to **ShoppingCartOrder**, and `isshoppingcartororder` is set to **ShoppingCart**. The `orderitems` array contains the items that you added to the cart. You should observe that many of the fields, such as `unitcost`, `totalcost`, and `dateplaced` are 0 or empty. These fields will be givne values when the shopping cart becomes a confirmed order—you will add this feature in the next exercise:

    ```JSON 
    [
        {
            "id": "3b572667-f49f-4017-ab5c-c137e095fb2f",
            "partitionkey": "2",
            "isshoppingcartororder": "ShoppingCart",
            "orderitems": [
                {
                    "productnumber": "BK-R93R-56",
                    "productname": "Road-150 Red, 56",
                    "productid": "753",
                    "subcategory": "Road Bikes",
                    "numberincartorordered": 5,
                    "numberonbackorder": 0,
                    "backorderreference": null,
                    "unitcost": 0,
                    "lineitemtotalcost": 0
                },
                {
                    "productnumber": "BK-M82B-42",
                    "productname": "Mountain-100 Black, 42",
                    "productid": "776",
                    "subcategory": "Mountain Bikes",
                    "numberincartorordered": 4,
                    "numberonbackorder": 0,
                    "backorderreference": null,
                    "unitcost": 0,
                    "lineitemtotalcost": 0
                }
            ],
            "numberofitems": 0,
            "itemscost": 0,
            "customerdiscountrate": 0,
            "totalcost": 0,
            "dateplaced": 0,
            "orderstatus": null,
            "lastupdated": 0,
            "doctype": "ShoppingCartOrder",
            "ttl": -1,
            "_rid": "CE1MAMJEDABQAwAAAAAAAA==",
            "_self": "dbs/CE1MAA==/colls/CE1MAMJEDAA=/docs/CE1MAMJEDABQAwAAAAAAAA==/",
            "_etag": "\"0000e205-0000-0000-0000-5b44e2800000\"",
            "_attachments": "attachments/",
            "_ts": 1531241088
        }
    ]
    ```

> **Result**: At the end of this exercise, you should have implemented the shopping cart.

## Exercise 3: Creating Orders and Backorders

### Exercise 3 Scenario

When a customer places an order, the application must determine whether there is sufficient of each item in stock, allocate stock to the order, and if necessary create one or more backorders. This process should be atomic for each order item. You can implement atomic transactions using triggers, however, in this case a stored procedure is more appropriate. This is because a trigger could only access data in the same partition as the shopping cart, and product details are held in different partitions. The solution is to iterate through the items in the shopping cart and execute a stored procedure for each item. The stored procedure can take the product ID and number required as parameters, together with any other pertinent information. The stored procedure can be run the the scope of the partition in which the product is stored, change the inventory level of the product, and create a backorder in the same partition, if necessary.

The main tasks for this exercise are as follows:

1.  Create a stored procedure to check stock levels.

2.  Test the new stored procedure.

3.  Add the capability to call stored procedures to the application.

4.  Update the application to use the new stored procedure to update stock levels.

5.  Test the new application functionality.

### Task 1: Create the CheckStockAvailable Stored Procedure

1.  Using the Azure Portal, add a new stored procedure to the **Data** collection.

2.  Set the `Id` of the procedure to **CheckStockAvailable**.

3.  Start the stored procedure definition with the following code. This code starts the definition of the `CheckStockAvailable` function, that will runs when the stored procedure is called. The parameters are *product ID* and *number required*, as described in the exercise scenario, together with the *product name* and *customer ID*; if it is necessary to create a backorder document, these details will be required. The `collection` and `collectionLink` variables reference the collection containing the stored procedure. You pass back information from a stored procedure using an HTTP response message:

    ```javascript 
    function CheckStockAvailable(productID, productname, numRequired, customerID){
        var collection = getContext().getCollection();
        var collectionLink = collection.getSelfLink();
        var response = getContext().getResponse();
    ```

4.  Add the following code to the stored procedure. This code uses the `queryDocuments` function to retrieve the details of the product. It runs a function (an anonymous one in this case) when the query is complete. This function takes three parameters; an object indicating whether an error occurred, an array of documents identified by the query, and an object containing the request options used to run the query. You will complete this function in the following steps:

    ```javascript 
        var isAccepted = collection.queryDocuments(collectionLink, "SELECT * FROM p WHERE p.doctype = 'Product' AND p.id = '" + productID + "'", {}, function(err, docs, options) {
    ```

5.  Add the following statement to the anonymous function. This code examines the error object, and if it is not null it rethrows the error. This will cause the stored procedure to abort, and any work performed will be undone. The error should be handled by the client running the stored procedure (the **Adventure-Works** application in this case). You will see how to do this later in the exercise:

    ```javascript 
        // If an error has occurred, abort the stored procedure
        if (err) {
            throw err;
        }
    ```

6.  Add the following statements to the stored procedure. This code verifies that the query found at least one product. If not, it throws a `not available` error back to the caller:

    ```javascript 
        // Check that a doc was found. If not, throw a "not available" error
        if (!docs || !docs.length) {
            throw new Error("Product " + productname + " is not available");
        }
    ```

7.  Append the following code to the function. This code checks that there is sufficient quantity of the product in stock. If not, it creates a backorder for the difference between quantity ordered and the quantity available. The `updateStockLevel` function (which you will write later) changes the available stock level of the product in the database. This code then calls the `createDocument` API function to add the backorder document to the database, using the same idiom as before to handle any errors. If the create is successful, the code creates a response message containing a JSON object specifies that a backorder was created, how many of the product was successfully allocated (the backorder covers the remainder), and the latest unit price per item:

    ```javascript 
        else {
            // If a matching product was found, check for sufficient stock levels
            var productDoc = docs[0];
            if (numRequired > productDoc.quantityinstock) {
    
                // If there is insufficient stock available, allocate what is there
                var numOnBackorder = numRequired - productDoc.quantityinstock;
                updateStockLevel(productDoc, productDoc.quantityinstock);
    
                // Create a backorder for the remainder
                var backorder = {
                    doctype: "ProductBackorder",
                    partitionkey: productDoc.partitionkey,
                    customerid: customerID,
                    productid: productDoc.id,
                    productname: productDoc.productname,
                    productnumber: productDoc.productnumber,
                    numberonbackorder: numOnBackorder,
                    backorderstatus: "In progress",
                    backorderdate: getCurrentTimeInNetTicks()
                };
    
                // Add the backorder to the database.
                // If an error occurs, the stored procedure will be aborted and changes rolled back
                isAccepted = collection.createDocument(collectionLink, backorder, function(err, backorderDoc, options){
                    // If an error has occurred, abort the stored procedure
                    if (err) {
                        throw err;
                    }
    
                    // Set the response body to indicate how many items were allocated, and the details of any backorder
                    response.setBody('{message: "backorder created", backorderid: "' + backorderDoc.id + '", allocated: ' + (numRequired - numOnBackorder) + ', latestprice:' + productDoc.listprice + '}');
                });
    
                if (!isAccepted) {
                    throw new Error('Unable to create backorder. Please retry.');
                }
            }
    ```

8.  Add the following JavaScript statements to the stored procedure. This code handles the case where there is sufficient stock available, so the stock level can be updated without creating a backorder:

    ```javascript 
            else {
                    // If there is sufficient stock available, then allocate it
                    updateStockLevel(productDoc, numRequired);
                    response.setBody('{message: "items in stock", allocated: ' + numRequired + ', latestprice:' + productDoc.listprice + '}');
                }
            }
        });
    ```

9.  Add the following statements to the code. The previous processing was initiated by calling the `queryDocument` function. However, if the Cosmos DB runtime determines that there is insufficient time available to perform the query, the return value from the `queryDocument` function is false. In this case, the code below causes the stored procedure to be aborted:

    ```javascript 
        if (!isAccepted) {
            throw new Error('Unable to check stock level. Please retry.');
        }
    ```

10. Add the following function to the end of the JavaScript code. This function uses the JavaScript API to safely update the stock level for a product. It uses the ETag of the product (retrieved previously) to ensure that no other customer has changed the stock level in the meantime:

  > **Note:** Ideally, rather than throwing an error if an update conflict occurs, this function would fetch the latest version of the product again, test the stock level, create a backorder if necessary, and then modify the stock level accordingly. This process is left as an exercise that you might like to try later, if you have time.
    
    ```javascript 
        function updateStockLevel(productDoc, numRequired) {
            // Update the stock level
            productDoc.quantityinstock -= numRequired;
    
            // Save the product doc back to the collection, and check for concurrent updates
            // If an error occurs, the stored procedure will be aborted and changes rolled back
            isAccepted = collection.replaceDocument(productDoc._self, productDoc, {etag: productDoc.Etag});
            if (!isAccepted) {
                throw new Error('Unable to update stock level. Please retry.');
            }
        }
    ```

11. Finally, add the `getCurrentTimeInNetTicks` function shown below to the code. This function returns the current time in .NET ticks (as opposed to JavaScript ticks):

    ```javascript 
        function getCurrentTimeInNetTicks() {
            // Get the current time
            var now = new Date().getTime();
    
            // Adjust for 1st Jan 1970
            const ticksBetweenYear1And1970 = 62135596800000;
            now += ticksBetweenYear1And1970
    
            // Convert the value in now from ms to 100 ns
            now *= 10000;
    
            // Return the result
            return now;
        }
    ```

12. Add a closing brace, **}** to the end of the `checkStockAvailable` function, after the `getCurrentTimeInNetTicks` function.

  > **Note:** The complete code for the stored procedure is available in the **CheckStockAvailable.txt** file, in the E:\\Labfiles\\Lab03 folder.

13. Click **Save** to save the stored procedure.

### Task 2: Test the CheckStockAvailable Stored Procedure

1.  In the Azure portal, select the **Data** collection, and then click **New SQL Query**.

2.  Run the following query. This query should return the details of product 788. This product is a mountain bike. Make a note of the value of the `quantityinstock` property:

    ```SQL 
    SELECT * FROM c WHERE c.id = "788"
    ```

3.  Return to the **CheckStockAvailable** stored procedure, and then click **Execute**.

4.  On the **Input parameters** blade, set **Partition key value** to **Mountain Bikes** (this is a subcategory name, which is used to partition products).
    
      - Provide **788** as the product id parameter. This is the product ID of one type of mountain bike.
    
      - Provide **Mountain 300, Black, 48** as the product name parameter. This is the product name of the mountain bike.
    
      - Provide **3** as the order quantity parameter. This is the number of bikes required.
    
      - Provide **99** as the customer id parameter. This is the customer ID.

5.  Run the stored procedure. You should see a result message similar to the following. This is the JSON data for the response body generated by the stored procedure:

    ```JSON 
    "{message: \"items in stock\", allocated: 3, latestprice:1079.99}"
    ```

6.  Re-run to the SQL Query you entered earlier. Verify that the value of the `quantityinstock` property has decreased by 3.

7.  Run the stored procedure again, but this time change the value of the order quantity parameter from **3** to **300**.. This time, the stored procedure has attempted to reserve more mountain bikes than are in stock and should have created a backorder. You should see a response message similar to this (the number allocated may vary, depending on how many times you have performed the previous steps):

    ```JSON 
    "{message: \"backorder created\", backorderid: \"638c2d72-3118-f848-4b83-05bc3138e7b2\", allocated: 122, latestprice:1079.99}"
    ```

8.  Re-run to the SQL Query you entered earlier. Verify that the value of the `quantityinstock` property has dropped to 0.

9.  Change the query as shown below and then click **Execute Query** again:

    ```SQL 
    SELECT * FROM c WHERE c.doctype = "ProductBackorder"
    ```

10. Verify that the query fetches the `ProductBackorder` document created by the stored procedure. The document `id` should match that shown in the response message of the stored procedure:

    ```JSON 
    [
        {
            "doctype": "ProductBackorder",
            "partitionkey": "Mountain Bikes",
            "customerid": "99",
            "productid": "788",
            "productname": "Mountain-300 Black, 48",
            "productnumber": "BK-M47B-48",
            "numberonbackorder": 178,
            "backorderstatus": "In progress",
            "backorderdate": 636668966127900000,
            "id": "638c2d72-3118-f848-4b83-05bc3138e7b2",
            "_rid": "CE1MAMJEDABRAwAAAAAAAA==",
            "_self": "dbs/CE1MAA==/colls/CE1MAMJEDAA=/docs/CE1MAMJEDABRAwAAAAAAAA==/",
            "_etag": "\"0000f705-0000-0000-0000-5b45c7e40000\"",
            "_attachments": "attachments/",
            "_ts": 1531299812
        }
    ]
    ```

11. Run the stored procedure again, but this time change the value of the product ID parameter from **788** to **7888** (a non-existent product). The stored procedure should throw an error similar to the error shown below, with a message specifying that the product is not available:

    ```JSON 
    {"code":400,"body":"{\"code\":\"BadRequest\",\"message\":\"Message: {\\\"Errors\\\":[\\\"Encountered exception while executing function. Exception = Error: Product Mountain 300, Black, 48 is not available\\\\r\\\\nStack trace: Error: Product Mountain 300, Black, 48 is not available\\\\n at Anonymous function (Test.js:15:13)\\\\n at Anonymous function (Test.js:608:29)\\\"]}\\r\\nActivityId: 0ca5911e-f5e1-4391-8e1a-5758ac824e22, Request URI: /apps/3666e0f0-ed7d-4e2e-8558-f69907b4ff5d/services/2ddcc7a4-a41f-456d-b304-cff7a21c84e0/partitions/a71482ca-4b9a-4c7b-b0cd-e5474963bc97/replicas/131751096055871999p, RequestStats: , SDK: Microsoft.Azure.Documents.Common/2.0.0.0\"}","activityId":"0ca5911e-f5e1-4391-8e1a-5758ac824e22"}
    ```

### Task 3: Add Stored Procedure Functionality to the Repository

1.  Using Visual Studio open the the **Adventure-Works.sln** solution in **E:\\Labfiles\\Lab03\\Starter\\Exercise03\\Adventure-Works**. This solution contains an extended version of the app from Exercise 2, with the addition of a controller and views for managing orders and backorders.

2.  Edit the **App.config** file. Set the `EndpointUrl` and `PrimaryKey` settings to the values you recorded for the Cosmos DB account that you created at the beginning of the lab. Confirm that the values of the `Database` and `Collection` settings match your Cosmos DB database and collection.

3.  Open the **Repository.cs** file, then find the `ExecuteStoredProcAsync` method at the end of the `Repository<T>` class. The purpose of this method is to run a stored procedure, The name of the stored procedure is passed in as the `storedProc` parameter, and the partition key that defines the scope of the stored procedure is specified in the `partitionKey` parameter. Any arguments to be passed to the stored procedure are held in the `paramList` array.

4.  After the comment **TODO: Get the URI of the stored procedure**, add the following statement:

    ```csharp 
    Uri storedProcUri = UriFactory.CreateStoredProcedureUri(database, collection, storedProc);
    ```

5.  After the comment **TODO: Specify the partition identified by the partitionKey parameter**, add the following code. You specify the partition using the `PartionKey` option in the request options header sent to Cosmos DB when it runs the stored procedure:

    ```csharp 
    var options = partitionKey == null ? null : new RequestOptions
    {
        PartitionKey = new PartitionKey(partitionKey)
    };
    ```

6.  After the comment **TODO: Run the stored procedure**, add the following statement. This statement invokes the stored procedure, passing in any parameters expected by the stored procedure:

    ```csharp 
    var storedProcResults = await client.ExecuteStoredProcedureAsync<dynamic>(storedProcUri, options, paramList);
    ```

7.  Change the statement after the comment **TODO: Pass back the results of the stored procedure** as follows. This statement passes the body of the response message back to the caller. This message will contain a JSON object indicating whether a backorder was created, the number of items allocated, and the latest price of the product, as shown in the previous exercise:

    ```csharp 
    return storedProcResults.Response;
    ```

### Task 4: Call the CheckStockAvailable Stored Procedure From the App Using the Repository

1.  In the **Controllers** folder, open the **OrdersController.cs** file. The code in this file implements a controller that enables a customer to view and manage orders.

2.  Expand the **helper methods** region at the start of the class and examine the `GetOrdersForCustomerAsync` method. This method uses the `ShoppingCartOrder` repository to retrieve the orders for a specified customer and cache them in the session:

    ```csharp 
    private async Task<List<ShoppingCartOrder>> GetOrdersForCustomerAsync(Customer customer)
    {
        // Find the orders for the customer
        var orders = await Repository<ShoppingCartOrder>.GetItemsAsync(
            o => o.DocType == nameof(ShoppingCartOrder) && o.IsShoppingCartOrOrder == Constants.ORDER && o.CustomerID == customer.CustomerID);
    
        // Cache the orders in the Session
        var ordersList = orders.ToList();
        Session["orders"] = ordersList;
    
        // Return the list of orders
        return ordersList;
    }
    ```
    
    > **Note:** There is a similar method named `GetBackordersForCustomerAsync` which retrieves and caches any backorders that the customer might have.

3.  Find the `ViewOrdersAsync` method in the `OrdersController` class. This method is similar to that used to display shopping cart data, expect that it displays orders (and fetches any backorders).

    ```csharp 
    // Method that fetches and displays the orders for the customer
    [ActionName("ViewOrders")]
    [HttpGet]
    public async Task<ActionResult> ViewOrdersAsync()
    {
        // Check whether the user has logged in
        if (Session["customer"] == null)
        {
            // If not, then get them to log in
            Session["ReturnData"] = new { ReturnURL = "ViewOrders", Controller = "Orders" };
            return View("Login");
        }
    
        // Retrieve the orders for the customer
        var orders = await GetOrdersForCustomerAsync(Session["customer"] as Customer);
    
        // Fetch and cache the backorders as well
        await GetBackordersForCustomerAsync(Session["customer"] as Customer);
    
        // Display the orders
        return View(orders);
    }
    ```

4.  Open the **ViewOrders** view in the **Views/Orders** folder. This is the view generated by the `ViewOrdersAsync` method. It iterates through the list of orders in the input model and displays the order ID, date placed, cost, and status of the order. The view also provides two buttons; **Cancel** which the user can click to cancel an order that hasn't yet been shipped (you will implement this functionality later in the lab), and **Details** which will display the line items in the order by calling the `OrderDetails` action of the `Orders` controller (you can examine the code for this action and the corresponding `OrderDetails` view in your own time).

5.  Open the **Global.asax.cs** file. After the comment **TODO: Add ProductBackorder repository**, add the following statement:

    ```csharp 
    Repository<ProductBackorder>.Initialize(ConfigurationManager.AppSettings["Collection"]);
    ```
    
    > **Note:** Orders are stored in the `ShoppingCartOrder` repository that you created earlier.

6.  Open the **ShoppingCartController.cs** file in the **Controllers** folder. This is the controller that you created in exercise 2. At the end of the controller, find the `PlaceOrderAsync` method. This is the method that runs when the user clicks **Place Order** when viewing their shopping cart. Most of the code in this method is currently missing.
    
    1.  After the comment **TODO: Create a dictionary for tracking whether backorders are created (if insufficient stock is currently available for any order item)**, add the following statement. The dictionary will be used to hold the product name and backorder ID for any backorders created. This information will be used to display a message to the customer when the order has been placed:
    
        ```csharp 
        var backorderDetails = new Dictionary<string, string>();
        ```
    
        2.  After the two-line comment starting **TODO: Use a stored procedure to check that sufficient stock is available for each item, allocate the stock for this order, or create a backorder if necessary**, add the following code. The first statement uses the `Product` repository to run the `CheckStockAvailable` stored procedure. The product subcategory is the partion key. The remaining parameters are passed to the stored procedure by the repository. The second statement parses and deserializes the response from the stored procedure; remember from the earlier tasks thet the response body is a JSON object containing fields named `message`, `backorderid`, `allocated`, and `latestprice`:
    
        ````csharp 
        var response = await Repository<Product>.ExecuteStoredProcAsync("CheckStockAvailable", item.Subcategory, item.ProductID, item.ProductName, item.NumberInCartOrOrdered, (Session["customer"] as Customer).CustomerID);
        var responseData = JsonConvert.DeserializeAnonymousType(response, new { message = "", backorderid = "", allocated = 0, latestprice = 0.0M });```
        ````
    
        3.  Add the following block of code after the comment **TODO: Check for backordered items**. If a backorder was created, the backorder ID and product name are added to the `backorderDetails` dictionary. The backorder ID is also recorded in the order line item, and the number on backorder is calculated and also added to the order line item:
    
        ```csharp 
        if ((responseData as dynamic).backorderid != null)
        {
            backorderDetails.Add(item.ProductName, (responseData as dynamic).backorderid);
            item.NumberOnBackorder = item.NumberInCartOrOrdered - (responseData as dynamic).allocated;
            item.BackorderReference = (responseData as dynamic).backorderid;
        }
        ```
    
        4.  After the comment **TODO: Update the order item with the most up to date cost of the item, and the number allocated**, add the following statements:
    
        ```csharp 
        item.NumberInCartOrOrdered = (responseData as dynamic).allocated;
        item.UnitCost = (responseData as dynamic).latestprice;
        item.LineItemTotalCost = (responseData as dynamic).allocated * (responseData as dynamic).latestprice;
        ```
    
        5.  After the comment **TODO: Mark the order as a confirmed order**, add the following line of code. This statement changes the type of the document from `ShoppingCart` to `Order`:
    
        ```csharp 
        shoppingCart.IsShoppingCartOrOrder = Constants.ORDER;
        ```
    
        6.  After the comment **TODO: Save the order to the database**, add the following code. This code calls the `UpsertItemAsync` method of the `ShoppingCartOrder` repository to save the order (including the order line items) to the database. If the dictionary indicates that any backorders were created, the code generates a message listing the products and backorder IDs which will be displayed to the customer. The shopping cart is then removed from the cache.
    
        ```csharp 
        if (await Repository<ShoppingCartOrder>.UpsertItemAsync(shoppingCart))
        {
            StringBuilder message = new StringBuilder();
            message.Append("Order placed.");
            foreach (var backorder in backorderDetails)
            {
                message.Append($"\\nBackorder created for {backorder.Key}: Reference {backorder.Value}");
            }
            TempData["itemMessage"] = message.ToString();
        
            // Remove the shopping cart from the Session cache as it is no longer required
            Session.Remove("shoppingCart");
        }
        else
        {
            TempData["itemMessage"] = "Order not placed";
        }
        ```
    
        7.  In the `catch` block that handles the `DocumentClientException` exception, after the comment **TODO: In the event of an exception, return to the ViewCart display and show the error message**, add the code shown below. Remember that if the stored procedure fails it throws an error. This code catches the error as a `DocumentClientException` exception. The error message from the stored procedure contains a lot of information about the location of the error in the stored procedure code (see the earlier task in this exercise, when testing the stored procedure with a non-existent product). While useful for debugging, this information is irrelevant to the customer. The most important part of the message is the contents of the Error object thrown by the stored procedure; this contains a message such as **Product mountain bike not found**, or **Unable to create backorder. Please retry**. The code below uses a regular expression to isolate this content and extract it from the exception, and then display it to the customer. Remember that if an exception occurs while running a stored procedure, any changes made by the stored procedure are discarded.
    
        ```csharp 
        Regex errMsgPattern = new Regex(@".*(?<error>Error:.*)\\r\\nStack.*");
        Match errMsgMatch = errMsgPattern.Match(dce.Message);
        if (errMsgMatch.Success)
        {
            TempData["itemMessage"] = errMsgMatch.Groups["error"].Value;
        }
        else
        {
            TempData["itemMessage"] = dce.Message;
        }
        return RedirectToAction("ViewCart", "ShoppingCart");
        ```

7.  Build and run the web application. Browse the catalog and add items to the shopping cart. On the **Shopping Cart** page, click **Place Order**. Verify that the order is created and is displayed on the **Orders** page. Observe that some details, such as the date placed, cost, and status of the order have not been set yet; you will do this using a trigger that fires when the shopping cart is converted into an order in the database, in the next exercise.

8.  Place another order that generates a backorder (attempt to buy 5000 items of a specific product). When you save the order, the **Order placed** message should include a backorder reference. When you view the details of the order, you should see that a quantity (5000 minus the number that was in stock) is on backorder, together with a link for the backorder reference. Click the link and examine the details of the backorder.

9.  Close the application and return to Data Explorer in the Azure Portal. Run the following SQL query. Replace **~~n~~** with the customer ID that you used to place the orders. Verify that your orders appear:

    ```SQL 
    SELECT * FROM c WHERE c.doctype = "ShoppingCartOrder" AND c.partitionkey = "~n~"
    ```

10. Run the following query to find any backorders that have been created:

    ```SQL 
    SELECT * FROM c WHERE c.doctype = "ProductBackorder"
    ```

> **Result**: At the end of this exercise, you should have implemented a stored procedure to manage stock levels and create backorders when a customer places an order.

## Exercise 4: Maintaining Data and Auditing Orders and Backorders

### Exercise 4 Scenario

When an order is created from items in the shopping cart, you need to calculate the total cost of the order and apply any discounts to which the customer might be entitled. You will create a pre-trigger for orders that performs this task, and also fills in the remaining details of the order that could not be completed earlier.

The app enables a customer to cancel orders and backorders that have not been shipped. For accounting and audit purposes, these changes need to be recorded in an audit trail. You will create a post-trigger that creates audit documents when an order or backorder is cancelled.

> **Note:** In this exercise, you will extend the functionality of the Adventure-Works web application. You can either continue using the solution from Exercise 3, or open the **Adventure-Works** solution in the **E:\\Labs\\Lab03\\Starter\\Exercise04\\Adventure-Works folder**. These instructions assume that you use the solution in the **E:\\Labs\\Lab03\\Starter\\Exercise04\\Adventure-Works** folder.

The main tasks for this exercise are as follows:

1.  Create a pre-trigger to complete details of an order.

2.  Create a post-trigger to maintain an audit trail.

3.  Extend the application to work with triggers.

4.  Test the triggers.

5.  Close down the lab.

### Task 1: Create a Pre-Trigger that Completes the Details of an Order

1.  Using the Azure Portal, create a new trigger in the **Data** collection.
    
      - Set the Id of the new trigger to **CompleteOrderDetails**.
    
      - Set the **Trigger Type** to **Pre**.
    
      - Set the **Trigger Operation** to **All**.

2.  Add the following JavaScript statements to the body of the trigger function. In a pre-trigger, the document being inserted, updated, or deleted is available in the body of the HTTP request which is part of the context for the JavaScript function:

    ```javascript 
    var context = getContext();  
    var request = context.getRequest();
    var collection = context.getCollection();  
    var documentBeingUpdated = request.getBody();
    ```

3.  Add the following code to the function. You only want this trigger to fire when an shopping cart is being converted to an order (an upsert), rather than when the item is being created or deleted. Note that **upsert** is not one of the options available in the **Trigger Operation** list, which is why the check is being performed by using code:

    ```javascript 
    // If the operation being performed is not an upsert, then ignore this trigger
    if (request.getOperationType() != "Upsert") {
        return;
    }
    ```

4.  Add the following JavaScript block that verifies that the trigger is being called against a `ShoppingCartOrder` document, and not some other type of data:

    ```javascript 
    // Verify the type of the document
    if (!("doctype" in documentBeingUpdated) && documentBeingUpdated.doctype != "ShoppingCartOrder") {
        throw new Error("Wrong type of document");
    }
    ```

5.  Add the code shown below to the function. This block determines how many items are in the order, and the total cost before applying any discounts:

    ```javascript 
    // Accumulator for counting the number of individual items in the order
    var numberOfItemsInOrder = 0;
    
    // Accumulator for counting the total cost of the order (before any customer discount)
    var costOfItemsInOrder = 0;
    
    // Iterate through the order items in the shopping cart
    documentBeingUpdated.orderitems.forEach(function (orderitem) {
    
        // Calculate the total number of items in the order, and the cost of these items
        numberOfItemsInOrder += orderitem.numberincartorordered;
        costOfItemsInOrder += orderitem.lineitemtotalcost;
    });
    ```

6.  Add the following code to the function. This code retrieves the discount rate for the customer. It aborts the trigger (and rolls back any changes made) if an error occurs or the customer doesn't exist:

    ```javascript 
    // Find the discountrate for the customer
    var isAccepted = collection.queryDocuments(collection.getSelfLink(), "SELECT * FROM c WHERE c.doctype = 'Customer' AND c.partitionkey = '" + documentBeingUpdated.partitionkey + "'", {}, function(err, customerDocs, options){
        // Report any errors
        if (err) {
            throw new Error(err);
        }
    
        // If the specified customer was not found in the collection throw an error with a suitable message
        if (customerDocs.length < 1) {
            throw new Error("Customer " + documentBeingUpdated.partitionkey + " not found");
        }
    ```

7.  Append the code shown below to the function. This code sets the fields in the order and calculates the cost using the customer's discount rate. This rate is specified as a percentage in between 0 and 100 in the customer document:

    ```javascript 
        // Extract the discount rate from the customer document
        var discountrate = customerDocs[0].discountrate;
    
        // Apply the discount to the order
        documentBeingUpdated.numberofitems = numberOfItemsInOrder;
        documentBeingUpdated.itemscost = costOfItemsInOrder;
        documentBeingUpdated.customerdiscountrate = discountrate;
        documentBeingUpdated.totalcost = documentBeingUpdated.itemscost * (100 - discountrate) / 100;
    
        // Set the order status, date placed, and date last updated
        documentBeingUpdated.orderstatus = "In progress";
        documentBeingUpdated.dateplaced = getCurrentTimeInNetTicks();
        documentBeingUpdated.lastupdated = getCurrentTimeInNetTicks();
    });
    ```

8.  Add the function `getCurrentTimeInNetTicks` to the trigger:

    ```javascript 
    function getCurrentTimeInNetTicks() {
        // Get the current time
        var now = new Date().getTime();
    
        // Adjust for 1st Jan 1970
        const ticksBetweenYear1And1970 = 62135596800000;
        now += ticksBetweenYear1And1970
    
        // Convert the value in now from ms to 100 ns
        now *= 10000;
    
        // Return the result
        return now;
    }
    ```

9.  Add the following code to complete the trigger. Note that the final statement changes the body of the HTTP request that invoked the trigger to reflect the changes made to the document. If you don't do this, the original document will be used, and you will lose the changes made by the trigger.

    ```javascript 
    // If the trigger is out of runtime, throw an error
    if (!isAccepted) {
        throw new Error('Unable to get customer details');
    }
    
    // Save the changes made to the order
    request.setBody(documentBeingUpdated);
    ```
    
    > **Note:** The complete code for the trigger is available in the file **CompleteOrderDetails.txt** in the E:\\Labfiles\\Lab03 folder.

10. Save the trigger when you have finished editing.

### Task 2: Create a Post-trigger that Audits Changes Made to Orders and Backorders

1.  Add a new trigger to the **Data** collection
    
      - Set the trigger Id to **AuditOrder**.
    
      - Set the **Trigger Type** to **Post**.
    
      - Set the **Trigger Operation** to **All**.

2.  Add the following JavaScript statements to the body of the trigger function. In a post-trigger, the document has already been written to the database, but its contents are available in the HTTP response message which you can access using the `getResponse` API function:

    ```javascript 
    var context = getContext();  
    var response = context.getResponse();
    var collection = context.getCollection();  
    var documentBeingUpdated = response.getBody();
    ```

3.  Add the following code to the function to verify that the document being processed is either an order or a backorder.

    ```javascript 
    // Verify the type of the document
    if (!("doctype" in documentBeingUpdated) && documentBeingUpdated.doctype != "ShoppingCartOrder" && documentBeingUpdated.docType != "ProductBackorder") {
        throw new Error("Wrong type of document");
    }
    ```

4.  Add the following code that creates a new audit document using the information in the order or backorder. Notice that the `partitionkey` field is set to the same value as that of the document being updated. This will cause the document to be stored in the same partition; you cannot add documents to other partitions in a trigger:

    ```javascript 
    // Create a document with the audit details
    var auditDocument = {
        partitionkey: documentBeingUpdated.partitionkey,
        doctype: "AuditDocument",
        doctypebeingaudited: documentBeingUpdated.doctype,
        documentbeingaudited: documentBeingUpdated.id,
        datechanged: getCurrentTimeInNetTicks(),
        statuschangedto: documentBeingUpdated.doctype == "ShoppingCartOrder" ? documentBeingUpdated.orderstatus : documentBeingUpdated.backorderstatus,
        customerid: documentBeingUpdated.doctype == "ShoppingCartOrder" ? documentBeingUpdated.partitionkey : documentBeingUpdated.customerid
    };
    ```

5.  Add the following code that saves the audit document to the database:

    ```javascript 
    // Add the audit document to the database
    var isAccepted = collection.createDocument(collection.getSelfLink(), auditDocument);
    
    // If the trigger is out of runtime, throw an error
    if (!isAccepted) {
        throw new Error('Unable to create audit record');
    }
    ```

6.  Add the `getCurrentTimeInNetTicks` function shown below to the trigger. This is the same function that was used by the stored procedure. Cosmos DB does not currently permit triggers and stored procedures to share code (you cannot call a UDF from a stored procedure or trigger either):

    ```javascript 
    function getCurrentTimeInNetTicks() {
        // Get the current time
        var now = new Date().getTime();
    
        // Adjust for 1st Jan 1970
        const ticksBetweenYear1And1970 = 62135596800000;
        now += ticksBetweenYear1And1970
    
        // Convert the value in now from ms to 100 ns
        now *= 10000;
    
        // Return the result
        return now;
    }
    ```
    
    > **Note:** The complete code for the trigger is available in the file **AuditOrder.txt** in the E:\\Labfiles\\Lab03 folder.

7.  Save the trigger when you have finished editing.

### Task 3: Add Trigger Functionality to the Repository

1.  Using Visual Studio open the the **Adventure-Works.sln** solution in **E:\\Labfiles\\Lab03\\Starter\\Exercise04\\Adventure-Works**. This solution contains a finished version of the app from Exercise 3.

2.  Edit the **App.config** file. Set the `EndpointUrl` and `PrimaryKey` settings to the values you recorded for the Cosmos DB account that you created at the beginning of the lab. Confirm that the values of the `Database` and `Collection` settings match your Cosmos DB database and collection.

3.  Open the **Repository.cs** file and locate the `UpsertItemAsync` method. This method runs when the app attempts to perform an upsert operation on a document.

4.  Examine the parameters for this method; as well as the document being `upserted`, the method takes two optional lists containing the names of pre and post triggers, and a `ttl` value:

    ```csharp 
    // Insert/update an item in the collection and optionally provide lists of pre- and post-triggers to run
    public static async Task<bool> UpsertItemAsync(T item, List<string> preTriggers = null, List<string> postTriggers = null, int ttl = -1)
    {
        ...
    }
    ```

5.  After the comment **TODO: Set the TTL of the document**, add the following statement:

    ```csharp 
    item.TimeToLive = ttl;
    ```

6.  After the comment **TODO: Specify the triggers to be invoked (if any)**, add the following code. This code creates a `RequestOptions` object that specifies the names of the triggers passed in to the method:

    ```csharp 
    var options = new RequestOptions
    {
        PreTriggerInclude = preTriggers,
        PostTriggerInclude = postTriggers
    };
    ```

7.  Replace the statement after the comment **TODO: Add/replace the document in the collection and invoke the triggers** with the following code. This code calls the UpsertDocumentAsync method but now includes the `RequestOptions` object that specifies the triggers to be run as part of the request:

    ``` 
    var response = await client.UpsertDocumentAsync(collectionUri, item, options);
    ```

### Task 4: Invoke the Triggers

1.  Open the **ShoppingCartController.cs** file in the **Controllers** folder and find the `PlaceOrderAsync` method at the end of the class.
    
    1.  In this method, find the following statement:
    
        ```csharp 
        // Save the order to the database
        if (await Repository<ShoppingCartOrder>.UpsertItemAsync(shoppingCart))
        ```
    
        2.  Update the call to the `UpsertItemAsync` method of the `ShoppingCartOrder` repository to specify that the `CompleteOrderDetails` pre-trigger should be run as part of the operation:
    
        ```csharp 
        if (await Repository<ShoppingCartOrder>.UpsertItemAsync(shoppingCart, preTriggers: new List<string> { "CompleteOrderDetails" }))
        ```

2.  Open the **OrdersController.cs** file in the **Controllers** folder and find the `CancelOrderAsync` method. As its name suggests, this method runs when the customer attempts to cancel an order.
    
    1.  In this method, find the following comment and line of code:
    
        ```csharp 
        // TODO: Save the order, and fire AuditOrder post-trigger
        if (1==0)
        ```
    
        2.  Replace the `if` statement with the following code. This statement calls the `UpsertItemAsync` method and specifies that the `AuditOrder` post-trigger should run as part of the operation:
    
        ```csharp 
        if (await (Repository<ShoppingCartOrder>.UpsertItemAsync(orderToCancel, postTriggers: new List<string> { "AuditOrder" })))
        ```
    
        3.  Find the comment **TODO: Save the backorder, and fire the AuditOrder post-trigger**. After this comment, add the following code:
    
        ```csharp 
        if (await (Repository<ProductBackorder>.UpsertItemAsync(backorderToCancel, postTriggers: new List<string> { "AuditOrder" })))
        {
            message.Append($"\nBackorder {orderItem.BackorderReference} cancelled");
        }
        ```
    
        4.  Find the `CancelBackorderAsync` method at the end of the class. In this method, after the comment **TODO: Save the backorder, and fire the AuditOrder post-trigger**, add the following code:
    
        ```csharp 
        if (await (Repository<ProductBackorder>.UpsertItemAsync(backorderToCancel, postTriggers: new List<string> { "AuditOrder" })))
        {
            TempData["itemMessage"] = $"Backorder {backorderID} cancelled";
        }
        ```

3.  Build and run the web application. Browse the catalog and add items to the shopping cart, and create a new order. When the **Orders** page appears, verify that the date placed, cost, and order status are now filled in.

4.  Place another order that generates a backorder (attempt to buy 5000 items of a specific product). When you save the order, the **Order placed** message should include a backorder reference. When you view the details of the order, you should see that a quantity (5000 minus the number that was in stock) is on backorder, together with a link for the backorder reference. Click the link and examine the details of the backorder.

5.  Close the application and return to Data Explorer in the Azure Portal. Run the following SQL query. Replace **~~n~~** with the customer ID that you used to place the orders. Verify that your orders appear:

    ```SQL 
    SELECT * FROM c WHERE c.doctype = "ShoppingCartOrder" AND c.partitionkey = "~n~"
    ```

6.  Run the following query to find any backorders that have been created:

    ```SQL 
    SELECT * FROM c WHERE c.doctype = "ProductBackorder"
    ```

### Task 5: Lab close down

1.  Close any open instances of Visual Studio and File Explorer.

2.  To reduce your costs delete the **20777\_Mod03** resource group containing your Cosmos DB database and storage account.

> **Result**: In this lab, you have used server-side programming to add functionality to the online sales applications.

---
© 2018 Microsoft Corporation. All rights reserved.

The text in this document is available under the [Creative Commons Attribution 3.0 License](https://creativecommons.org/licenses/by/3.0/legalcode), additional terms may apply. All other content contained in this document (including, without limitation, trademarks, logos, images, etc.) are **not** included within the Creative Commons license grant. This document does not provide you with any legal rights to any intellectual property in any Microsoft product. You may copy and use this document for your internal, reference purposes.

This document is provided "as-is." Information and views expressed in this document, including URL and other Internet Web site references, may change without notice. You bear the risk of using it. Some examples are for illustration only and are fictitious. No real association is intended or inferred. Microsoft makes no warranties, express or implied, with respect to the information provided here.
